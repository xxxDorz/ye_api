import { useRef, useEffect, createElement, Fragment } from 'react';
import { SIDE_OPTIONS, getPlacementData } from '@radix-ui/popper';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ":root {\n  --inspx-margin-color: #f24822;\n  --inspx-padding-color: #0bb658;\n  --inspx-size-color: #0070f3;\n  --inspx-active-color: #0070f330;\n}\n\ninspx {\n  box-sizing: border-box;\n  height: 20px;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans',\n    'Helvetica Neue', sans-serif;\n  font-size: 11px;\n  line-height: 20px;\n  text-align: center;\n  border-radius: 4px;\n  color: white;\n  padding: 0 4px;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 1337;\n}\n\n[data-inspx-active] {\n  background: var(--inspx-active-color) !important;\n}\n\nmargin {\n  background: var(--inspx-margin-color);\n  opacity: 0.4;\n}\n\npadding {\n  border-color: var(--inspx-padding-color);\n  border-style: solid;\n  opacity: 0.4;\n}\n\ninspx[type='margin'] {\n  background: var(--inspx-margin-color);\n}\n\ninspx[type='padding'] {\n  background: var(--inspx-padding-color);\n}\n\ninspx[type='size'] {\n  background: var(--inspx-size-color);\n}\n";
styleInject(css_248z);

var isCloke = false;
function Inspect(_ref) {
  var children = _ref.children,
      _ref$margin = _ref.margin,
      margin = _ref$margin === void 0 ? true : _ref$margin,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? true : _ref$padding,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? true : _ref$size,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? process.env.NODE_ENV !== 'development' : _ref$disabled;
  var nodesAtPointerRef = useRef([]);
  useEffect(function () {
    function onKeyDown(e) {
      if (e.key === 'Alt') {
        if (margin) inspectMargin(nodesAtPointerRef.current);
        if (size) inspectSize(nodesAtPointerRef.current);
        if (padding) inspectPadding(nodesAtPointerRef.current);
      }
    }

    function onKeyUp(e) {
      if (e.key === 'Alt') {
        uninspect();
      }
    }

    function onInspxSwitch() {
      if (isCloke) {
        uninspect();
      } else {
        if (margin) inspectMargin(nodesAtPointerRef.current);
        if (size) inspectSize(nodesAtPointerRef.current);
        if (padding) inspectPadding(nodesAtPointerRef.current);
      }

      isCloke = !isCloke;
    }

    if (!disabled) {
      window.addEventListener('keyup', onKeyUp);
      window.addEventListener('keydown', onKeyDown); // @ts-ignore

      window.addEventListener('inspxswitch', onInspxSwitch);
    }

    return function () {
      window.removeEventListener('keyup', onKeyUp);
      window.removeEventListener('keydown', onKeyDown); // @ts-ignore

      window.removeEventListener('inspxswitch', onInspxSwitch);
    };
  }, [margin, size, padding, disabled]);

  if (disabled) {
    return createElement(Fragment, null, children);
  }

  return createElement("span", {
    onMouseOver: function onMouseOver(e) {
      e.stopPropagation();
      uninspect();
      var nodes = document.elementsFromPoint(e.clientX, e.clientY);
      nodesAtPointerRef.current = nodes;

      if (e.altKey || isCloke) {
        if (margin) inspectMargin(nodes);
        if (size) inspectSize(nodes);
        if (padding) inspectPadding(nodes);
      }
    }
  }, children);
} ////////////////////////////////////////////////////////////////////////////////
// Imperative code is amazing.

function createMarkerNode(text, type, popperOptions) {
  var marker = document.createElement('inspx');
  marker.innerText = text;
  marker.setAttribute('type', type);
  document.body.appendChild(marker);

  var _marker$getBoundingCl = marker.getBoundingClientRect(),
      popperWidth = _marker$getBoundingCl.width,
      popperHeight = _marker$getBoundingCl.height;

  var _getPlacementData = getPlacementData(_extends({
    popperSize: {
      width: popperWidth,
      height: popperHeight
    },
    sideOffset: 8,
    align: 'center',
    side: 'bottom',
    alignOffset: 0,
    collisionBoundariesRect: DOMRect.fromRect({
      width: window.innerWidth,
      height: window.innerHeight,
      x: 0,
      y: 0
    }),
    collisionTolerance: 0,
    shouldAvoidCollisions: true
  }, popperOptions)),
      popperStyles = _getPlacementData.popperStyles;

  Object.entries(popperStyles).forEach(function (_ref2) {
    var key = _ref2[0],
        value = _ref2[1];
    marker.style.setProperty(key, value);
  });
}

function createMargin(index, value, node, side) {
  var margin = document.createElement('margin');

  var _node$getBoundingClie = node.getBoundingClientRect(),
      nodeWidth = _node$getBoundingClie.width,
      nodeHeight = _node$getBoundingClie.height;

  var widths = [nodeWidth, value, nodeWidth, value];
  var heights = [value, nodeHeight, value, nodeHeight];
  var width = widths[index];
  var height = heights[index];
  style(margin, {
    width: width,
    height: height
  });

  var _getPlacementData2 = getPlacementData({
    popperSize: {
      width: width,
      height: height
    },
    sideOffset: 0,
    align: 'start',
    side: side,
    alignOffset: 0,
    collisionBoundariesRect: DOMRect.fromRect({
      width: window.innerWidth,
      height: window.innerHeight,
      x: 0,
      y: 0
    }),
    anchorRect: node.getBoundingClientRect(),
    collisionTolerance: 0,
    shouldAvoidCollisions: false
  }),
      popperStyles = _getPlacementData2.popperStyles;

  style(margin, popperStyles);
  document.body.appendChild(margin);
}

function inspectMargin(nodes) {
  var marginNodes = nodes.filter(hasMargin);
  var node = marginNodes[0];

  if (!node) {
    return;
  }

  node.setAttribute('data-inspx-active', '');

  var _window$getComputedSt = window.getComputedStyle(node),
      marginTop = _window$getComputedSt.marginTop,
      marginRight = _window$getComputedSt.marginRight,
      marginBottom = _window$getComputedSt.marginBottom,
      marginLeft = _window$getComputedSt.marginLeft;

  var margins = [marginTop, marginRight, marginBottom, marginLeft].map(function (m) {
    return parseInt(m, 10);
  });
  margins.forEach(function (margin, index) {
    if (!margin) {
      return;
    }

    createMarkerNode(String(margin), 'margin', {
      anchorRect: node.getBoundingClientRect(),
      side: SIDE_OPTIONS[index],
      shouldAvoidCollisions: false,
      sideOffset: margin / 2 - 10
    });
    createMargin(index, margin, node, SIDE_OPTIONS[index]);
  });
}

function inspectSize(nodes) {
  var sizeNodes = nodes.filter(hasSize);
  var node = sizeNodes[0];

  if (!node) {
    return;
  }

  node.setAttribute('data-inspx-active', '');

  var _node$getBoundingClie2 = node.getBoundingClientRect(),
      width = _node$getBoundingClie2.width,
      height = _node$getBoundingClie2.height,
      top = _node$getBoundingClie2.top,
      left = _node$getBoundingClie2.left,
      right = _node$getBoundingClie2.right,
      bottom = _node$getBoundingClie2.bottom;

  var marker = document.createElement('inspx');
  marker.innerText = Math.round(width) + " x " + Math.round(height);
  marker.setAttribute('type', 'size');
  document.body.appendChild(marker);

  var _marker$getBoundingCl2 = marker.getBoundingClientRect(),
      markerWidth = _marker$getBoundingCl2.width,
      markerHeight = _marker$getBoundingCl2.height;

  var x = (left + right) / 2 - markerWidth / 2;
  var y = (top + bottom) / 2 - markerHeight / 2;
  style(marker, getPlacementStylesForPoint({
    x: x,
    y: y
  }));
}

function createPadding(node, paddings) {
  var padding = document.createElement('padding');

  var _node$getBoundingClie3 = node.getBoundingClientRect(),
      width = _node$getBoundingClie3.width,
      height = _node$getBoundingClie3.height,
      x = _node$getBoundingClie3.x,
      y = _node$getBoundingClie3.y;

  style(padding, _extends({}, getPlacementStylesForPoint({
    x: x,
    y: y
  }), {
    width: width,
    height: height,
    'border-top-width': paddings[0],
    'border-right-width': paddings[1],
    'border-bottom-width': paddings[2],
    'border-left-width': paddings[3]
  }));
  document.body.appendChild(padding);
}

function inspectPadding(nodes) {
  var marginNodes = nodes.filter(hasPadding);
  var node = marginNodes[0];

  if (!node) {
    return;
  }

  node.setAttribute('data-inspx-active', '');

  var _window$getComputedSt2 = window.getComputedStyle(node),
      paddingTop = _window$getComputedSt2.paddingTop,
      paddingRight = _window$getComputedSt2.paddingRight,
      paddingBottom = _window$getComputedSt2.paddingBottom,
      paddingLeft = _window$getComputedSt2.paddingLeft;

  var paddings = [paddingTop, paddingRight, paddingBottom, paddingLeft].map(function (m) {
    return parseInt(m, 10);
  });
  paddings.forEach(function (padding, index) {
    if (!padding) {
      return;
    }

    createMarkerNode(String(padding), 'padding', {
      anchorRect: node.getBoundingClientRect(),
      side: SIDE_OPTIONS[index],
      shouldAvoidCollisions: false,
      sideOffset: -padding / 2 - 10
    });
  });
  createPadding(node, paddings);
} ////////////////////////////////////////////////////////////////////////////////
// Helpers.


function uninspect() {
  Array.from(document.querySelectorAll('[data-inspx-active]')).forEach(function (node) {
    node.removeAttribute('data-inspx-active');
  });
  Array.from(document.querySelectorAll('inspx')).forEach(function (marker) {
    document.body.removeChild(marker);
  });
  Array.from(document.querySelectorAll('margin')).forEach(function (marker) {
    document.body.removeChild(marker);
  });
  Array.from(document.querySelectorAll('padding')).forEach(function (marker) {
    document.body.removeChild(marker);
  });
}

function isDefined(margin) {
  return !!parseInt(margin, 10);
}

function hasMargin(node) {
  var styles = window.getComputedStyle(node);
  return isDefined(styles.marginTop) || isDefined(styles.marginRight) || isDefined(styles.marginBottom) || isDefined(styles.marginLeft) || isDefined(styles.margin);
}

function hasPadding(node) {
  var styles = window.getComputedStyle(node);
  return isDefined(styles.paddingTop) || isDefined(styles.paddingRight) || isDefined(styles.paddingBottom) || isDefined(styles.paddingLeft) || isDefined(styles.padding);
}

function hasSize(node) {
  var styles = window.getComputedStyle(node);
  return isDefined(styles.width) && isDefined(styles.height);
}

function style(node, styles) {
  Object.entries(styles).forEach(function (_ref3) {
    var key = _ref3[0],
        value = _ref3[1];
    node.style.setProperty(key, typeof value === 'number' ? value + 'px' : value);
  });
}

function getPlacementStylesForPoint(point) {
  var x = Math.round(point.x + window.scrollX);
  var y = Math.round(point.y + window.scrollY);
  return {
    position: 'absolute',
    top: 0,
    left: 0,
    minWidth: 'max-content',
    willChange: 'transform',
    transform: "translate3d(" + x + "px, " + y + "px, 0)"
  };
}

export default Inspect;
//# sourceMappingURL=inspx.esm.js.map
